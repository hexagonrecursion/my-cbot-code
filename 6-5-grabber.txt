extern void object::Grabber() {
	goto(new point(27, -202), 1, 1);
	FlyTo(new point(-29, -159));
	message("Island A");
	
	Cool(new point(-33, -154));
	FlyTo(new point(-81, -130));
	message("Island B; first ant");
	
	Cool(new point(-84, -117));
	FlyTo(new point(-92, -63));
	message("Island C; second ant");
	
	motor(0, 0);
	jet(0);
	while(temperature > 0);
	message("goto");
	point p0(-101, 15);
	while(distance2d(p0, position) > 3.5) {
		Motor(p0);
		jet(0.1 - 0.11 * temperature);
	}
	message("cool");
	Cool(p0);
	FlyTo(new point(-56, 64));
	message("Island D");
	
	Cool(new point(-44, 63));
	FlyTo1(new point(-8, 46));
	message("Island E (low)");
	
	Cool(new point(-8, 46));
	FlyTo(new point(41, 40));
	message("Island F");
	
	goto(new point(53, 42));
	FlyTo(new point(71, 99));
	message("Island G");
	
	Cool(new point(73, 99));
	goto(new point(73, 99), 1, 1);
	FlyTo(new point(101, 160));
	message("Island H");
	
	FlyTo(new point(47, 187));
	message("Island I");
	
	goto(new point(49, 192), 1, 1);
	message("waypoint A");
	goto(new point(-10, 193), 1, 1);
	message("waypoint B");
	goto(new point(-39, 214), 1, 1);
	message("waypoint C");
	goto(new point(-66, 222), 1, 1);
	message("waypoint D");
	goto(new point(-91, 207), 1, 1);
	message("waypoint E");
	Cool(new point(-91, 207));
	FlyTo(new point(-157, 225));
	message("Island I (second spot)");
	
	point waypoints[] = {
		new point(-166, 222),
		new point(-172, 168),
		new point(-198, 168)
	};
	for(int i = 0; i < sizeof(waypoints); ++i) {
		while(distance2d(position, waypoints[i]) > 4) {
			Motor(waypoints[i]);
		}
	}
	
	goto(new point(-198, 168));
	Cool(new point(-198, 168));
	FlyTo(new point(-237, 145));
	message("Island J");
	
	Cool(new point(-237, 145));
	goto(-246, 138);
	FlyTo(new point(-235, 71));
	message("Island K");
	
	point p1(-262, 64);
	turn(direction(p1));
	motor(0, 0);
	jet(-1);
	while(temperature > 0);
	while(distance2d(position, p1) > 1) {
		jet(0.1 * (topo(p1) + 1 - position.z));
		float fDir = direction(p1) / 100;
		motor(0.5 - fDir, 0.5 + fDir);
	}
	message("jumped");
	Cool(p1);
	message("cooled");
	turn(direction(new point(-310, 53)));
	message("turned");
	motor(0, 0);
	jet(-1);
	while(temperature > 0);
	message("cooled again");
	
	goto(new point(-310, 53), 1, 1);
	goto(new point(-347, 51), 1, 1);
	Grab(NuclearCell);
	goto(new point(-341, 80), 1, 1);
	Goto(WingedOrgaShooter);
	drop();
}

void object::FlyTo(point p) {
	message("Cooling " + temperature);
	while(temperature > 0.25);
	message("Turning " + temperature);
	turn(direction(p));
	message("Cooling again " + temperature);
	while(temperature > 0.25);
	message("Moving " + temperature);
	jet(-1);
	motor(1, 1);
	jet(-1);
	while(pitch > -20 && position.z > 3);
	message("Liftoff " + temperature);
	while(topo(position) < 0.99 * topo(p) || distance2d(position, p) > 10) {
		jet(0.1 * (topo(p) + 1 - position.z));
		float fDir = direction(p) / 100;
		motor(1 - fDir, 1 + fDir);
	}
	message("Done " + temperature);
	motor(0, 0);
	jet(-1);
}

void object::FlyTo1(point target) {
	message("Cooling " + temperature);
	while(temperature > 0.25);
	message("Moving " + temperature);
	turn(direction(target));
	motor(1, 1);
	jet(-1);
	while(pitch > -20);
	message("Liftoff "+temperature);
	while(topo(position) < 0 || distance2d(position, target) > 10) {
		float p = 0.025 * (topo(target) + 0.5 - position.z);
		float d = -0.05 * velocity.z;
		jet(p + d);
		float fDir = direction(target) / 100;
		motor(1 - fDir, 1 + fDir);
	}
	wait(0.25);
	message("Done " + temperature);
	motor(0, 0);
	jet(-1);
}

void object::Cool(point target) {
	while(temperature > 0.25) {
		if(distance(target, position) < 1) {
			motor(0, 0);
		} else {
			float forward = abs(direction(target)) > 10 ? 0 : distance2d(target, position);
			float fDir = direction(target) / 100;
			motor(forward - fDir, forward + fDir);
		}
	}
	motor(0, 0);
	jet(-1);
}


// Copied from utils.txt

/// Recharge if need to and able
void object::MaybeUsePowerStation(float threshold=0.5) {
	if(radar(PowerStation) == null) {
		return;
	}
	float energy = min(_GetEnergyLevel(load), _GetEnergyLevel(energyCell));
	if(energy > threshold) {
		return;
	}
	while(energy < 1) {
		float newEnergy = min(_GetEnergyLevel(load), _GetEnergyLevel(energyCell));
		// Because sometimes goto() stops early
		if(newEnergy <= energy) {
			Goto(PowerStation);
		}
		energy = newEnergy;
		wait(1);
	}
	GotoSpace();
}

/// Private. Do not use outside MaybeUsePowerStation()
float _GetEnergyLevel(object o) {
	if(o == null || o.category != PowerCell ) {
		return 1;
	}
	return o.energyLevel;
}

/// Go to an unoccupied space nearby
void object::GotoSpace() {
	// Using flatspace() because space() sometimes
	// returns locations on the ramp of the ship and goto() gets stuck
	Goto(flatspace(position, 1));
}

/// goto() a free spot for a building within `raduis` of the `center` and drop() there
///
/// Works around quirks of flatspace():
/// 1. flatspace(...) returns locations under water
/// 2. flatspace(center, ...) returns `center` instead of signalling an error
/// 3. Some buildings need a lot of space unoccupied by other buildings (max 14),
///    but space() and flatspace() too often overlook useable locations if dist=14
void DropAtBuildable(point center, float raduis) {
	point dropHere(nan, nan);
	for(int i = 1; i < 100; ++i) {
		point p(center.x + raduis*rand(), center.y +raduis*rand());
		point test = flatspace(p, 5, 0);
		if(test.x == nan) {
			continue;
		}
		if(topo(test) < 0) {
			continue;
		}
		if(distance2d(test, center) > raduis) {
			continue;
		}
		if(search(Any, test, 0, 14) != null) {
			continue;
		}
		if(flatground(test, 5) < 5) {
			continue;
		}
		if(dropHere.x == nan || distance2d(test, center) < distance2d(dropHere, center)) {
			dropHere = test;
		}
	}
	if(dropHere.x == nan) {
		message("DropAtBuildable: suitable location not found");
		throw GetUnusedErrorCode();
	}
	Goto(dropHere);
	move(-1.2); // adjust because robots drop items about 1.2 ahead of them
	drop();
}

/// Wait for an object to appear, goto() it, and grab() it
///
/// Works around quirks of the built-in grab():
/// 1. grab() sometimes grabs thin air
/// 2. grab() sometimes grabs a different object from the one you intended
void object::Grab(
    int what,
    point pos=new point(nan, nan),
    float min=0,
    float max=1000,
    float sens=1,
    int filter=FilterNone
) {
	while(load == null || load.category != what) {
		if(load != null) {
			drop(); // TODO: error handling
		}
		Goto(what, pos, min, max, sens, filter);
		grab(); // TODO: RawGrab()
	}
}

/// goto() an object and grab() it
///
/// Works around quirks of the built-in grab():
/// 1. grab() sometimes grabs thin air
/// 2. grab() sometimes grabs a different object from the one you intended
void object::Grab(object what) {
	while(load != what) {
		if(load != null) {
			drop(); // TODO: error handling
		}
		Goto(what);
		grab(); // TODO: RawGrab()
	}
}

/// Wait for an object to appear and goto() it (with retry)
void object::Goto(
    int where,
    point pos=new point(nan, nan),
    float min=0,
    float max=1000,
    float sens=1,
    int filter=FilterNone
) {
	// note: using RawGoto() instead of Goto(object) because maybe a different object is not closer
	while(RawGoto(WaitSearch(where, pos, min, max, sens, filter).position) != 0) {
		message(category + ": goto failed");
		wait(1);
	}
}

/// goto(where.position) with retry
void object::Goto(object where) {
	// note: using RawGoto() instead of Goto(point) because where.position may have changed
	while(RawGoto(where.position) != 0) {
		message(category + ": goto failed");
		wait(1);
	}
}

/// goto() with retry
void object::Goto(point where) {
	if(where.x == nan || where.y == nan) {
		message("can't go to nan");
		throw GetUnusedErrorCode();
	}
	while(RawGoto(where) != 0) {
		message(category + ": goto failed");
		wait(1);
	}
}


/// error-code-returning versions of built-ins that do not alter the current errmode
int RawGoto(point where, float altitude=0, int goal=-1, int crash=-1) {
	try {
		goto(where, altitude, goal, crash);
		return 0;
	} catch(210 /* goto impossible */) {
		return 210;
	} catch(211 /* goto too complicated */) {
		return 211;
	} catch(212 /* goto destination occupied */) {
		return 212;
	}
	return iNever();
}

int RawBuild(int what) {
	try {
		build(what);
		return 0;
	} catch(120 /* not possible in flight */) {
		return 120;
	} catch(121 /* not possible under water */) {
		return 121; 
	} catch(123 /* lack of metal (too far) */) {
		return 123; 
	} catch(124 /* lack of metal (too close) */) {
		return 124; 
	} catch(125 /* lack of metal */) {
		return 125; 
	} catch(126 /* not enough flat ground */) {
		return 126; 
	} catch(127 /* not enough flat ground space */) {
		return 127; 
	} catch(128 /* location occupied */) {
		return 128; 
	} catch(129 /* too close to the rocket */) {
		return 129; 
	} catch(130 /* buildings too close */) {
		return 130; 
	} catch(131 /* not possible in movement */) {
		return 131; 
	} catch(132 /* can not produce this object in this mission */) {
		return 132; 
	} catch(133 /* can not produce not researched object */) {
		return 133; 
	}
	return iNever();
}

/// Wait from an object of a specific category to appear and return it
object object::WaitSearch(
    int what,
    point pos=new point(nan, nan),
    float min=0,
    float max=1000,
    float sens=1,
    int filter=FilterNone
) {
	if(pos.x == nan) {
		pos = position;
	}
	object p;
	do {
		p = search(what, pos, min, max, sens, filter);
	} while (p == null);
	return p;
}


/// motor() toward a point
void object::Motor(point target) {
	float forward = abs(direction(target)) > 45 ? 0 : distance2d(target, position);
	float fDir = distance(target, position) < 0.5 ? 0 : direction(target) / 100;
	motor(forward - fDir, forward + fDir);
}

/// Aim and fire
void object::Shoot(point target) {
	float myGunZ = position.z + 1;  // position.z is the bottom of the robot, I need the z of the gun
	float vAngle = atan((target.z - myGunZ) / distance2d(target, position));
	aim(vAngle - pitch, -direction(target));
	fire(0.1);
}


/// min/max
float min(float a, float b) {
	if(a < b) {
		return a;
	}
	return b;
}

float max(float a, float b) {
	if(a > b) {
		return a;
	}
	return b;
}


/// Vector math
point add(point a, point b) {
	a.x += b.x;
	a.y += b.y;
	a.z += b.z;
	return a;
}

point sub(point a, point b) {
	a.x -= b.x;
	a.y -= b.y;
	a.z -= b.z;
	return a;
}

point mul(float f, point p) {
	p.x *= f;
	p.y *= f;
	p.z *= f;
	return p;
}


/// convert to/from angles
/// Point + angle + length
point PAL(point p, float angle, float length) {
	p.x += length * cos(angle);
	p.y += length * sin(angle);
	return p;
}

float Angle(point from, point to) {
	return atan2(to.y - from.y, to.x - from.x);
}


/// Suppress the "non-void function needs return" compiler error
object oNever() {
	message("will never get here");
	throw GetUnusedErrorCode();
	return null;
}

point pNever() {
	message("will never get here");
	throw GetUnusedErrorCode();
	return new point();
}

int iNever() {
	message("will never get here");
	throw GetUnusedErrorCode();
	return 0;
}


/// return an error code not used by the game
int GetUnusedErrorCode() {
	return 10;
}
